Function:
=========
This interface represents a function that takes one argument and produces a result. In the context of streams, you can use Function to map elements of the stream to another value.Example:
.map(Function<? super T, ? extends R> mapper): Maps each element of the stream to another value using the provided function.
.flatMap(Function<? super T, ? extends Stream<? extends R>> mapper): Maps each element to a stream and then flattens the resulting streams into a single stream.
.reduce(U identity, BinaryOperator<U> accumulator): Performs a reduction on the elements of the stream using the provided identity value and an associative accumulation function.
collect(Collector<? super T, A, R> collector): Performs a mutable reduction operation using the provided Collector.

java
Copy code
// Using Function to map each element to its square
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
                               .map(x -> x * x)
                               .collect(Collectors.toList());


Predicate: Predicate represents a boolean-valued function of one argument. Predicates are often used to filter elements in a stream based on some condition.Example:
.filter(Predicate<? super T> predicate): Filters the elements of the stream based on the provided predicate.
.anyMatch(Predicate<? super T> predicate): Checks if any element of the stream matches the provided predicate.
.allMatch(Predicate<? super T> predicate): Checks if all elements of the stream match the provided predicate.
.noneMatch(Predicate<? super T> predicate): Checks if none of the elements of the stream match the provided predicate.

java
Copy code
// Using Predicate to filter even numbers
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(x -> x % 2 == 0)
                                   .collect(Collectors.toList());
Consumer:- 
=========
Consumer represents an operation that accepts a single input argument and returns no result. It's commonly used for performing some action on each element of the stream.Example:
.forEach(Consumer<? super T> action): Performs the given action for each element of the stream.
.forEachOrdered(Consumer<? super T> action): Performs the given action for each element of the stream in encounter order.
.peek(Consumer<? super T> action): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

java
Copy code
// Using Consumer to print each element
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println("Hello, " + name));

Supplier:-
=========
Supplier represents a supplier of results. It has a method get() that returns a result. Suppliers are often used to generate or supply 
values.Example:
.generate(Supplier<T> s): Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
.iterate(T seed, UnaryOperator<T> f): Returns an infinite sequential ordered Stream produced by iterative application of the provided function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
.of(T... values): Returns a sequential ordered stream whose elements are the specified values.
java
Copy code
// Using Supplier to generate a stream of random numbers
Supplier<Double> randomSupplier = Math::random;
Stream<Double> randomNumbers = Stream.generate(randomSupplier).limit(10);
randomNumbers.forEach(System.out::println);

==========================================================================================================================

